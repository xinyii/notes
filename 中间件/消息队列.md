---
date created: 2023-02-10 23:34
date updated: 2023-02-16 23:29
---

# 概念

## Kafka

| 概念                  | 说明                                                          |
| ------------------- | ----------------------------------------------------------- |
| Broker 代理           | 消息服务器，作为 Server 提供消息核心服务                                    |
| Topic 主题            | 发布订阅模式下的消息统一汇集地，不同生产者向 Topic 发送消息，由 MQ 服务器分发到不同的订阅者，实现消息的广播 |
| Partition 分区        | 物理上的概念，每个Topic包含一个或者多个Partition                             |
| Queue 队列            | PTP 模式下，特定生产者向特定 Queue 发送消息，消费者订阅特定的 Queue 完成指定消息的接收        |
| Message 消息体         | 根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输                     |
| Productor 生产者       | 业务的发起方，负责生产消息传输给 Broker                                     |
| Consumer 消费者        | 业务的处理方，负责从 Broker 获取消息并进行业务逻辑处理                             |
| Consumer Group 消费者组 | 每个组仅一个消费者消费，不同组可以重复消费                                       |

# 对比

| 特性                 | ActiveMQ                  | RabbitMQ                                                 | RocketMQ                                                              | Kafka                           |
| ------------------ | ------------------------- | -------------------------------------------------------- | --------------------------------------------------------------------- | ------------------------------- |
| **单机吞吐量**          | 万级                        | 万级                                                       | 十万级                                                                   | 十万级（优势）                         |
| **Topic数量对吞吐量的影响** |                           |                                                          | Topic可以达到几千个的级别，吞吐量小幅下降。同等数量机器支撑大量的Topic。（优势）                         | Topic到几百个的时候，吞吐量会大幅下降。          |
| **时效性**            | 毫秒级                       | 微秒级（优势）                                                  | 毫秒级                                                                   | 毫秒级                             |
| **可用性**            | 高，主从                      | 高，主从                                                     | 非常高，分布式                                                               | 非常高                             |
| **消息可靠性**          | 较低概率丢失                    |                                                          | 零丢失                                                                   | 零丢失                             |
| **功能支持**           | 及其完备                      | erlang开发，并发高（优势）                                         | 分布式扩展性好                                                               | 功能简单                            |
| **优势**             | 非常成熟，功能强大，在业内大量公司和项目中都有应用 | erlang语言开发，性能极好、延时很低，吞吐量万级、MQ功能完备，管理界面非常好，社区活跃；互联网公司使用较多 | 接口简单易用，阿里出品有保障，吞吐量大，分布式扩展方便、社区比较活跃，支持大规模的Topic、支持复杂的业务场景，可以基于源码进行定制开发 | 超高吞吐量，ms级的时延，极高的可用性和可靠性，分布式扩展方便 |
| **劣势**             | 偶尔有较低概率丢失消息，社区活跃度不高       | 吞吐量较低，erlang语音开发不容易进行定制开发，集群动态扩展麻烦                       | 接口不是按照标准JMS规范走的，有的系统迁移要修改大量的代码，技术有被抛弃的风险                              | 有可能进行消息的重复消费                    |
| **应用**             | 主要用于解耦和异步，较少用在大规模吞吐的场景中   | 都有使用                                                     | 用于大规模吞吐、复杂业务中                                                         | 在大数据的实时计算和日志采集中被大规模使用，是业界的标准    |
| Github Star        | 2.1k                      | 10.4k                                                    | 18.7k                                                                 | 24.2k                           |
| 开发语言               | Java                      | Erlang                                                   | Java                                                                  | Java、Scala                      |

# 常见问题

## 1. 优点

1. 解耦：一个服务挂了，不影响整个系统。
2. 异步：避免阻塞，提高并发。
3. 削峰：保证系统稳定。

## 2. 缺点

1. 系统可用性降低。
2. 系统复杂度提高。
3. 一致性问题。

## 3. 高可用

1. RabbitMQ 镜像集群。
2. Kafka 副本机制。

## 4. 可靠性

1. 生产者消息丢失
   1. RabbitMQ 事务。(同步，不推荐)
   2. RabbitMQ confirm 模式。（异步，推荐）
2. MQ 中消息丢失
   1. RabbitMQ 消息持久化。
3. 消费者消息丢失
   1. RabbitMQ 关闭自动 ACK。

## 5. 顺序性

1. 单例消费者。

## 6. 积压

1. 修复 Consumer 的 BUG。
2. 用临时程序将 Queue 积压的消息分散到多个 Queue。
3. 添加多个 Consumer 来并行消费多个 Queue。
4. 如果 Message 过期丢失，需要重发消息。
5. 如果难处理，则丢弃消息，然后重发消息消费。

## 7. 设计

1. 可伸缩（分布式，数据分区）
2. 高吞吐（顺序读写）
3. 高可用（选举）
4. 可靠性（确认机制）

# 参考

- <https://note.dolyw.com/mq/>
